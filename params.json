{
  "name": "Introducción e Historia",
  "tagline": "",
  "body": "# Filosofía del Paradigma.\r\n\r\n##Generalidades\r\n\r\nDebemos comenzar con el hecho de que existe un gran debate en cuanto a si la _programación orientada a aspectos_ es o no un paradigma, muchas personas afirman el que es solamente una extensión de la _programación orientada a objetos_. Por contraparte, existen las personas que definen la _programación orientada a aspectos_ como un paradigma nuevo que, aunque sigue a _POO_ y por ende soporta la clasificación por objetos, no necesariamente debe hacerlo, es decir, idealmente _POA_ es aplicable a otros paradigmas como podría ser la descomposición funcional. En nuestro caso, decidimos tomar la _programación orientada a aspectos_ como un paradigma.\r\n\r\n### Objetivo Principal\r\n\r\nLa _programación orientada a aspectos_ tiene como objetivo principal: \"brindar un contexto al programador que permita separar claramente componentes y aspectos, separando componentes entre sí, aspectos entre sí, y aspectos de componentes, a través de mecanismos que hagan posible abstraerlos y componerlos para producir el sistema completo.\"\r\n\r\n![](https://raw.githubusercontent.com/anfmorenoso/Archivos/master/Table.jpg)\r\n\r\n###Las \"6 C's\" de Mehmet Aksit\r\n\r\nLas 6 \"C's\" son un conjunto de conceptos propuestos por Mehmet Aksit y son las bases a la hora de generar software con programación orientada a aspectos. Una primera aproximación a lo que son los conceptos base de la misma:\r\n\r\n1. Entrecruzado (**C**rosscutting): El entrecruzado se basa en encapsular los conceptos transversales que existen en el código tradicional para luego entrecruzarlo con la funcionalidad principal que por ende también queda encapsulada. Éste entrecruzado hace que ambas, funcionalidad y aspectos queden totalmente funcionales sin necesidad de repetición de código.\r\n![](https://raw.githubusercontent.com/anfmorenoso/Archivos/master/cross.jpg)\r\n2. **C**anónico: Los conceptos transversales deben ser implementados de manera estable y completa, totalmente independientes entre ellos.\r\n3. **C**omposición: La implementación del modelo debe proveer factores de calidad, como adaptabilidad, reusabilidad y extensibilidad.\r\n4. **C**lausura: La implementación debe mantener la totalidad de los factores de calidad del diseño en la etapa de implementación para evitar problemas con los conceptos de funcionalidad y configuración. \r\n5. **C**omputabilidad: El software generado por la implementación orientada a aspectos debe ser funcional y ejecutable.\r\n6. **C**ertificabilidad: Los modelos de diseño e implementación deben ser evaluables en cada parte del proceso de desarrollo e implementación, además de ser controlable para aumentar o mantener la calidad del modelo.\r\n\r\n###Las \"4 S's\" de Harold Ossher:\r\n\r\nLas 4 S's se refieren a separación exitosa de conceptos por Harold Ossher y son las siguientes:\r\n\r\n1. **S**imultáneo: Los conceptos y composiciones importantes deben poder coexistir dentro del modelo completo sin interrumpirse.\r\n2. Auto-contenido (**S**elf-contained): Cada módulo debe declarar sus dependencias, con el objetivo de poder entender cada módulo por separado.\r\n3. **S**imétrico: Todos los conceptos deben ser encapsulados de la misma manera en cada módulo diferente, todo esto con el fin de obtener una mayor confiabilidad en la composición.\r\n4. Espontáneo (**S**pontaneous): Al agregar nuevos conceptos, la encapsulación, integración e identificación debe ser sencilla, incluyendo los conceptos que surjan en la etapa de implementación.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}