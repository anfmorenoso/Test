{
  "name": "Introducción e Historia",
  "tagline": "",
  "body": "# Introducción e historia.\r\n\r\n## Introducción\r\n\r\nA lo largo de la historia de la ingeniería de software se ha pasado por ciertas \"etapas\" en las que se hace uso de un concepto básico de la programación e incluso la vida diaria, dividir una gran tarea en pequeñas tareas manejables es mucho más sencillo que intentar realizar el todo, \"_divide y vencerás_\". En un inicio se tenía el código sin división alguna, datos y funcionalidades estaban mezcladas por todo el código, a esta etapa se le llama la generación del código \"espaghetti\":\r\n\r\n![](https://raw.githubusercontent.com/anfmorenoso/Archivos/master/Spag.jpg)\r\n\r\nLas formas tienen la función de representar los datos y los colores representan la funcionalidad, de ésta manera la imagen ilustra a lo que le llamamos el código \"espaghetti\".\r\n\r\nLuego de ésta generación de caos en el código llegó el primer gran paso en el uso del concepto \"_divide y vencerás_\". Los desarrolladores comenzaron a identificar las partes más manejables del código y lo expresaron como funciones definidas dentro del dominio del problema:\r\n\r\n![](https://raw.githubusercontent.com/anfmorenoso/Archivos/master/Func.jpg)\r\n\r\nDe ésta manera se consiguió encapsular de cierta manera las funcionalidades y haciendo que el incluir una nueva función fuera mucho mas sencillo, no obstante todavía existían inconvenientes ya que la claridad de las funciones era pobre debido a la utilización de datos compartidos, por otro lado el agregar un nuevo tipo de dato se convertía en una tarea de modificar cuanta función estuviera involucrada con el nuevo dato.\r\n\r\nFinalmente, en un intento por solucionar los problemas que dejaban los datos esparcidos por todo el código, nace la [Programación Orientada a Objetos](http://ferestrepoca.github.io/paradigmas-de-programacion/poo/index.html), la cual supuso un gran avance que es visible hasta el día de hoy siendo éste uno de los paradigmas de programación más importantes y usados de los últimos años. Su descomposición en objetos es mucho más acertada en el entorno real que la descomposición funcional.\r\n\r\n![](https://raw.githubusercontent.com/anfmorenoso/Archivos/master/obj.jpg)\r\n\r\nAunque la _programación orientada a objetos_ es un paradigma de programación que resuelve bastantes problemas de la programación tradicional como el integrar nuevos datos, no es perfecta y posee innumerables problemas dado a que las funciones continúan esparcidas por todo el código y para agregar una función nueva es necesario revisar y modificar objetos.\r\n\r\nAdemás, el diseño e ingeniería de software no se trata simplemente de tratar las funcionalidades básicas del problema, existen muchos otros conceptos que en la descomposición funcional y en la programación orientada a objetos son aproximados de manera poco eficiente, por ejemplo:\r\n\r\n1. La Sincronización.\r\n2. La Distribución.\r\n3. El Manejo de Errores.\r\n4. La Optimización de Memoria.\r\n5. La Gestión de la Seguridad.\r\n\r\nTodos estos conceptos se encuentran diseminados por todo el código, a veces incluso implementados múltiples veces, por cada objeto o clase que necesite de las mismas. Un código normal, implementado con paradigmas actuales puede lucir de la siguiente manera:\r\n\r\n![](https://raw.githubusercontent.com/anfmorenoso/Archivos/master/Cod.jpg)\r\n\r\nLa no separación de los conceptos transversales en la programación ocasiona distintos tipos de problemas como pueden ser:\r\n\r\n- Baja correspondencia: La implementación simultánea de varios conceptos oscurece la correspondencia entre un concepto y su implementación.\r\n- Baja productividad: Al intentar implementar varios conceptos en un mismo módulo existe la posibilidad de que el desarrollador pierda el rumbo del concepto principal por concentrarse en conceptos periféricos.\r\n- Baja reusabilidad: Al tener en un mismo módulo implementados varios conceptos, resulta en un código poco reusable.\r\n- Baja calidad de código: El código con múltiples conceptos entrelazados en un mismo módulo produce un código propenso a errores, por otro lado, al tener como objetivo demasiados varios conceptos es posible que se haga una mejor o peor implementación de los mismos por considerarlos más o menos importantes.\r\n- Evolución más dificultosa: Con una implementación que no esté completamente modularizada los futuros cambios en un requerimiento implican revisar y modificar cada uno de los módulos donde esté presente ese requerimiento.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}