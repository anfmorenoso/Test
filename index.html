<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Introducción e Historia by anfmorenoso</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Introducción e Historia</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/anfmorenoso/Test" class="btn">View on GitHub</a>
      <a href="https://github.com/anfmorenoso/Test/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/anfmorenoso/Test/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="introducción" class="anchor" href="#introducci%C3%B3n" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introducción.</h1>

<p>A lo largo de la historia de la ingeniería de software se ha pasado por ciertas "etapas" en las que se hace uso de un concepto básico de la programación e incluso la vida diaria, dividir una gran tarea en pequeñas tareas manejables es mucho más sencillo que intentar realizar el todo, "<em>divide y vencerás</em>". En un inicio se tenía el código sin división alguna, datos y funcionalidades estaban mezcladas por todo el código, a esta etapa se le llama la generación del código "espaghetti":</p>

<p><img src="https://raw.githubusercontent.com/anfmorenoso/Archivos/master/Spag.jpg" alt=""></p>

<p>Las formas tienen la función de representar los datos y los colores representan la funcionalidad, de ésta manera la imagen ilustra a lo que le llamamos el código "espaghetti".</p>

<p>Luego de ésta generación de caos en el código llegó el primer gran paso en el uso del concepto "<em>divide y vencerás</em>". Los desarrolladores comenzaron a identificar las partes más manejables del código y lo expresaron como funciones definidas dentro del dominio del problema:</p>

<p><img src="https://raw.githubusercontent.com/anfmorenoso/Archivos/master/Func.jpg" alt=""></p>

<p>De ésta manera se consiguió encapsular de cierta manera las funcionalidades y haciendo que el incluir una nueva función fuera mucho mas sencillo, no obstante todavía existían inconvenientes ya que la claridad de las funciones era pobre debido a la utilización de datos compartidos, por otro lado el agregar un nuevo tipo de dato se convertía en una tarea de modificar cuanta función estuviera involucrada con el nuevo dato.</p>

<p>Finalmente, en un intento por solucionar los problemas que dejaban los datos esparcidos por todo el código, nace la <a href="http://ferestrepoca.github.io/paradigmas-de-programacion/poo/index.html">Programación Orientada a Objetos</a>, la cual supuso un gran avance que es visible hasta el día de hoy siendo éste uno de los paradigmas de programación más importantes y usados de los últimos años. Su descomposición en objetos es mucho más acertada en el entorno real que la descomposición funcional.</p>

<p><img src="https://raw.githubusercontent.com/anfmorenoso/Archivos/master/obj.jpg" alt=""></p>

<p>Aunque la <em>programación orientada a objetos</em> es un paradigma de programación que resuelve bastantes problemas de la programación tradicional como el integrar nuevos datos, no es perfecta y posee innumerables problemas dado a que las funciones continúan esparcidas por todo el código y para agregar una función nueva es necesario revisar y modificar objetos.</p>

<p>Además, el diseño e ingeniería de software no se trata simplemente de tratar las funcionalidades básicas del problema, existen muchos otros conceptos que en la descomposición funcional y en la programación orientada a objetos son aproximados de manera poco eficiente, por ejemplo:</p>

<ol>
<li>La Sincronización.</li>
<li>La Distribución.</li>
<li>El Manejo de Errores.</li>
<li>La Optimización de Memoria.</li>
<li>La Gestión de la Seguridad.</li>
</ol>

<p>Todos estos conceptos se encuentran diseminados por todo el código, a veces incluso implementados múltiples veces, por cada objeto o clase que necesite de las mismas. Un código normal, implementado con paradigmas actuales puede lucir de la siguiente manera:</p>

<p><img src="https://raw.githubusercontent.com/anfmorenoso/Archivos/master/Cod.jpg" alt=""></p>

<p>La no separación de los conceptos transversales en la programación ocasiona distintos tipos de problemas como pueden ser:</p>

<ul>
<li>Baja correspondencia: La implementación simultánea de varios conceptos oscurece la correspondencia entre un concepto y su implementación.</li>
<li>Baja productividad: Al intentar implementar varios conceptos en un mismo módulo existe la posibilidad de que el desarrollador pierda el rumbo del concepto principal por concentrarse en conceptos periféricos.</li>
<li>Baja reusabilidad: Al tener en un mismo módulo implementados varios conceptos, resulta en un código poco reusable.</li>
<li>Baja calidad de código: El código con múltiples conceptos entrelazados en un mismo módulo produce un código propenso a errores, por otro lado, al tener como objetivo demasiados varios conceptos es posible que se haga una mejor o peor implementación de los mismos por considerarlos más o menos importantes.</li>
<li>Evolución más dificultosa: Con una implementación que no esté completamente modularizada los futuros cambios en un requerimiento implican revisar y modificar cada uno de los módulos donde esté presente ese requerimiento.</li>
</ul>

<h1>
<a id="historia" class="anchor" href="#historia" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Historia</h1>

<p><img src="https://raw.githubusercontent.com/anfmorenoso/Archivos/master/time.png" alt=""></p>

<p>La historia de la <em>programación orientada a aspectos</em> comienza en el año 1991 con el grupo <strong>Demeter</strong> quienes trabajaban investigando acerca de lo que podríamos denominar una etapa temprana de POA, la <em>programación adaptativa</em>, la cual, basada en basada en el uso de autómatas finitos y una teoría formal de lenguaje para expresar concisamente y procesar eficientemente conjuntos de caminos en un grafo arquitectónico, representó un gran avance dentro de la tecnología de software. </p>

<p>Este mismo grupo <strong>Demeter</strong> en el año de 1987 propuso la llamada "Ley Demeter", una regla aplicada en el diseño de software en sistemas basados en objetos: "Sólo conversa con tus amigos inmediatos", ésta ley inspiró en el desarrollo de la programación adaptativa y eventualmente la <em>programación orientada a aspectos</em> dado que para escribir código respetando ésta ley habían secciones del código que debían ser claramente encapsuladas para dejar la funcionalidad básica libre de cualquier concepto relacionado con el comportamiento del software.</p>

<p>No fue sino hasta 1995 cuando Cristina Lopes junto con Walter Huersch realizaron un reporte acerca de la separación de los conceptos de comportamiento de los conceptos de funcionalidad, incluso mencionaron técnicas iniciales para poder realizar dicha separación: filtros composicionales y <em>programación adaptativa</em> para tratar con los conceptos entrecruzados.</p>

<p><img src="https://raw.githubusercontent.com/anfmorenoso/Archivos/master/Cris.png" alt=""></p>

<p>En éste reporte se dejó claro como la separación de conceptos era uno de los retos más importantes en el progreso de la ingeniería de software.</p>

<p>En éste mismo año el grupo "Demeter" dio lo que sería la primera definición de Aspecto: "Un aspecto es una unidad que se define en términos de información parcial de otras unidades.", en éste grupo se encontraba Gregor Kickzales quien dentro de la literatura se considera como el creador de la <em>programación orientada a aspectos</em>.</p>

<p><img src="https://raw.githubusercontent.com/anfmorenoso/Archivos/master/Greg.png" alt=""></p>

<p>Cristina Lopes comenzó a trabajar con Kickzales y su grupo, eventualmente dejaron de lado a programación adaptativa para, a partir de la misma, crear la <em>programación orientada a aspectos</em></p>

<p>La programación orientada a aspectos es un paradigma muy joven, pero promete un gran potencial, tanto que se dice que la programación orientada a aspectos podría ser un nuevo salto en las generaciones de la ingeniería de software.</p>

<p><img src="https://raw.githubusercontent.com/anfmorenoso/Archivos/master/aspc.png" alt=""></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/anfmorenoso/Test">Introducción e Historia</a> is maintained by <a href="https://github.com/anfmorenoso">anfmorenoso</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
